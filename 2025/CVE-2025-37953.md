### [CVE-2025-37953](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-37953)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=73cf6af13153d62f9b76eff422eea79dbc70f15e%3C%20c928dd4f6bf0c25c72b11824a1e9ac9bd37296a0%20&color=brighgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=brighgreen)

### Description

In the Linux kernel, the following vulnerability has been resolved:sch_htb: make htb_deactivate() idempotentAlan reported a NULL pointer dereference in htb_next_rb_node()after we made htb_qlen_notify() idempotent.It turns out in the following case it introduced some regression:htb_dequeue_tree():  |-> fq_codel_dequeue()    |-> qdisc_tree_reduce_backlog()      |-> htb_qlen_notify()        |-> htb_deactivate()  |-> htb_next_rb_node()  |-> htb_deactivate()For htb_next_rb_node(), after calling the 1st htb_deactivate(), theclprio[prio]->ptr could be already set to  NULL, which meanshtb_next_rb_node() is vulnerable here.For htb_deactivate(), although we checked qlen before calling it, incase of qlen==0 after qdisc_tree_reduce_backlog(), we may call it againwhich triggers the warning inside.To fix the issues here, we need to:1) Make htb_deactivate() idempotent, that is, simply return if we   already call it before.2) Make htb_next_rb_node() safe against ptr==NULL.Many thanks to Alan for testing and for the reproducer.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/fkie-cad/nvd-json-data-feeds
- https://github.com/runwhen-contrib/helm-charts

