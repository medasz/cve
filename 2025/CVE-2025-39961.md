### [CVE-2025-39961](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-39961)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=0d50f7b1e8c80a8c20db5049e269468c059b0378%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=5.3%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=6fb92f18555a7b8e085267d513612dc0ff9a5360%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=754265bcab78a9014f0f99cd35e0d610fcd7dfa7%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=785ca708a908b9c596ede852470ba28b8dc3e40b%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=b15bf74405faa1a65025eb8a6eb337e140e5250a%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:iommu/amd/pgtbl: Fix possible race while increase page table levelThe AMD IOMMU host page table implementation supports dynamic page table levels(up to 6 levels), starting with a 3-level configuration that expands based onIOVA address. The kernel maintains a root pointer and current page table levelto enable proper page table walks in alloc_pte()/fetch_pte() operations.The IOMMU IOVA allocator initially starts with 32-bit address and onces itsexhuasted it switches to 64-bit address (max address is determined basedon IOMMU and device DMA capability). To support larger IOVA, AMD IOMMUdriver increases page table level.But in unmap path (iommu_v1_unmap_pages()), fetch_pte() readspgtable->[root/mode] without lock. So its possible that in exteme corner case,when increase_address_space() is updating pgtable->[root/mode], fetch_pte()reads wrong page table level (pgtable->mode). It does compare the value withlevel encoded in page table and returns NULL. This will result isiommu_unmap ops to fail and upper layer may retry/log WARN_ON.CPU 0                                         CPU 1------                                       ------map pages                                    unmap pagesalloc_pte() -> increase_address_space()      iommu_v1_unmap_pages() -> fetch_pte()  pgtable->root = pte (new root value)                                             READ pgtable->[mode/root]					       Reads new root, old mode  Updates mode (pgtable->mode += 1)Since Page table level updates are infrequent and already synchronized with aspinlock, implement seqcount to enable lock-free read operations on the read path.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/fkie-cad/nvd-json-data-feeds

