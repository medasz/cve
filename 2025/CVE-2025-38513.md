### [CVE-2025-38513](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38513)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=2.6.25%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=459c51ad6e1fc19e91a53798358433d3c08cd09d%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:wifi: zd1211rw: Fix potential NULL pointer dereference in zd_mac_tx_to_dev()There is a potential NULL pointer dereference in zd_mac_tx_to_dev(). Forexample, the following is possible:    	T0			    		T1zd_mac_tx_to_dev()  /* len == skb_queue_len(q) */  while (len > ZD_MAC_MAX_ACK_WAITERS) {					  filter_ack()					    spin_lock_irqsave(&q->lock, flags);					    /* position == skb_queue_len(q) */					    for (i=1; i<position; i++)				    	      skb = __skb_dequeue(q)					    if (mac->type == NL80211_IFTYPE_AP)					      skb = __skb_dequeue(q);					    spin_unlock_irqrestore(&q->lock, flags);    skb_dequeue() -> NULLSince there is a small gap between checking skb queue length and skb beingunconditionally dequeued in zd_mac_tx_to_dev(), skb_dequeue() can return NULL.Then the pointer is passed to zd_mac_tx_status() where it is dereferenced.In order to avoid potential NULL pointer dereference due to situations likeabove, check if skb is not NULL before passing it to zd_mac_tx_status().Found by Linux Verification Center (linuxtesting.org) with SVACE.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

