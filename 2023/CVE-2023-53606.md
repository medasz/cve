### [CVE-2023-53606](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-53606)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=1da177e4c3f41524e886b7f1b8a0c1fc7321cac2%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:nfsd: clean up potential nfsd_file refcount leaks in COPY codepathThere are two different flavors of the nfsd4_copy struct. One isembedded in the compound and is used directly in synchronous copies. Theother is dynamically allocated, refcounted and tracked in the clientstruture. For the embedded one, the cleanup just involves releasing anynfsd_files held on its behalf. For the async one, the cleanup is a bitmore involved, and we need to dequeue it from lists, unhash it, etc.There is at least one potential refcount leak in this code now. If thekthread_create call fails, then both the src and dst nfsd_files in theoriginal nfsd4_copy object are leaked.The cleanup in this codepath is also sort of weird. In the async copycase, we'll have up to four nfsd_file references (src and dst for bothflavors of copy structure). They are both put at the end ofnfsd4_do_async_copy, even though the ones held on behalf of the embeddedone outlive that structure.Change it so that we always clean up the nfsd_file refs held by theembedded copy structure before nfsd4_copy returns. Reworkcleanup_async_copy to handle both inter and intra copies. Eliminatenfsd4_cleanup_intra_ssc since it now becomes a no-op.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/fkie-cad/nvd-json-data-feeds

