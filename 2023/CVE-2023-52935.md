### [CVE-2023-52935](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-52935)
![](https://img.shields.io/static/v1?label=Product&message=Linux&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=4.8%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Version&message=f3f0e1d2150b2b99da2cbdfaad000089efe9bf30%20&color=brightgreen)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=blue)

### Description

In the Linux kernel, the following vulnerability has been resolved:mm/khugepaged: fix ->anon_vma raceIf an ->anon_vma is attached to the VMA, collapse_and_free_pmd() requiresit to be locked.Page table traversal is allowed under any one of the mmap lock, theanon_vma lock (if the VMA is associated with an anon_vma), and themapping lock (if the VMA is associated with a mapping); and so to beable to remove page tables, we must hold all three of them. retract_page_tables() bails out if an ->anon_vma is attached, but doesthis check before holding the mmap lock (as the comment above the checkexplains).If we racily merged an existing ->anon_vma (shared with a childprocess) from a neighboring VMA, subsequent rmap traversals on pagesbelonging to the child will be able to see the page tables that we areconcurrently removing while assuming that nothing else can access them.Repeat the ->anon_vma check once we hold the mmap lock to ensure thatthere really is no concurrent page table access.Hitting this bug causes a lockdep warning in collapse_and_free_pmd(),in the line "lockdep_assert_held_write(&vma->anon_vma->root->rwsem)". It can also lead to use-after-free access.

### POC

#### Reference
No PoCs from references.

#### Github
- https://github.com/w4zu/Debian_security

